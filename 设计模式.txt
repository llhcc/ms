
-----------------------------------------------------------
单一职责原则--一个职责一个接口,（单一职责适用于接口、类，同时也适用于方法）。
里氏替换原则--继承，只要父类能出现的地方子类就可以出现,有子类出现的地方，父类未必就能适应。
依赖倒置原则--
               那什么是抽象？什么又是细节
				呢？在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实
				现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是
				可以加上一个关键字new产生一个对象。依赖倒置原则在Java语言中的表现就是：
				● 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过
				接口或抽象类产生的；
				● 接口或抽象类不依赖于实现类；
				● 实现类依赖接口或抽象类。
接口隔离原则-- 接口尽量细化，同时接口中的方法尽量少
               接口分为两种:● 实例接口 ● 类接口
			   单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，
			   而接口隔离原则要求接口的方法尽量少
			   
迪米特法则----也称为最少知识原则,一个类应该对自己需要耦合或调用的类知道得最少
开闭原则------一个软件实体如类、模块和函数应该对扩展开放，对修改关闭
(前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖)
(开闭原则是一个终极目标，任何人包括大师级人物都无法百分之百做到，但朝这个方向
努力，可以非常显著地改善一个系统的架构，真正做到“拥抱变化”)

-------------------------------------------------------------
单例模式----确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例
public class Singleton {
	private static volatile Singleton singleton;
	private Singleton(){
	}
	public static Singleton getSingleton(){
		if(null == singleton){
			synchronized(Singleton.class){
				if(null == singleton){
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}
}
优点：减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化
缺点：扩展很困难

如在Spring中，每个Bean默
认就是单例的，这样做的优点是Spring容器可以管理这些Bean的生命期，决定什么时候创建
出来，什么时候销毁，销毁的时候要如何处理，等等。如果采用非单例模式（Prototype类
型），则Bean初始化后的管理交由J2EE容器，Spring容器不再跟踪管理Bean的生命周期.---scope="prototype"
---------------------------------------------------------------
工厂方法模式---定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类


工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类，其他的实
现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依
赖产品类的抽象；当然也符合里氏替换原则，使用产品子类替换产品父类

----------------------------------------------------------------
抽象工厂模式---为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类

最大缺点:就是产品族扩展非常困难
说横向扩展容易，纵向扩展困难----提到抽象工厂模式的产品族扩展比较困难，但是一定要
清楚，是产品族扩展困难，而不是产品等级。在该模式下，产品等级是非常容易扩展的，增
加一个产品等级，只要增加一个工厂类负责新增加出来的产品生产任务即可

(一个对象族（或是一组没有任何关系的对象）
都有相同的约束，则可以使用抽象工厂模式)

-----------------------------------------------------------------
模板方法模式---定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改
变一个算法的结构即可重定义该算法的某些特定步骤
(就是在模板方法中按照一定的规则和顺序调用基本方法)

父类怎么调用子类的方法:(不建议这么做)
● 把子类传递到父类的有参构造中，然后调用。
● 使用反射的方式调用，你使用了反射还有谁不能调用的？！
● 父类调用子类的静态方法。

-----------------------------------------------------------------
建造者模式---将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

(建造者模式和工厂模式非常相似呀，是的，非
常相似，但是记住一点你就可以游刃有余地使用了：建造者模式最主要的功能是基本方法的
调用顺序安排，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生
的对象也不同；而工厂方法则重点是创建，创建零件是它的主要职责，组装顺序则不是它关
心的。)


-------------------------------------------------------------------
代理模式---为其他对象提供一种代理以控制对这个对象的访问。
(你是想直接绕过她的代理，谁知道返回的还是她的代理，这就是强制代理)


-------------------------------------------------------------------
策略模式---定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。
致命缺陷：所有的策略都需要暴露出去，这样才方便客户端决定使用哪一个策略

策略枚举是一个非常优秀和方便的模式，但是它受枚举类型的限制，每个枚举项
都是public、final、static的，扩展性受到了一定的约束，因此在系统开发中，策略枚举一般
担当不经常发生变化的角色

-------------------------------------------------------------------
适配器模式---将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作

-------------------------------------------------------------------
迭代器模式---它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节


-------------------------------------------------------------------
组合模式---将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性

只要是树形结构，就要考虑使用组合模式，这个一定要记住，只要是要体现局部和整体
的关系的时候，而且这种关系还可能比较深，考虑一下组合模式吧
-------------------------------------------------------------------
观察者模式---定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新


-------------------------------------------------------------------
模式---



















